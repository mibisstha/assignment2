import { NextResponse } from 'next/server';
import { prisma } from '../../../lib/prisma';
import simpleGit from 'simple-git';
import fs from 'fs/promises';
import path from 'path';

export async function POST(request: Request) {
  const tempDir = path.join('/tmp', `git-${Date.now()}`);
  
  try {
    const body = await request.json();
    const { type, owner, repo, token, options } = body;

    if (!type || !owner || !repo) {
      return NextResponse.json(
        { error: 'Missing required fields: type, owner, repo' },
        { status: 400 }
      );
    }

    // Generate file content based on type
    let fileName = '';
    let content = '';

    switch (type) {
      case 'dockerfile':
        fileName = 'Dockerfile';
        content = generateDockerfile(options);
        break;
      case 'docker-compose':
        fileName = 'docker-compose.yml';
        content = generateDockerCompose(options);
        break;
      case 'prisma':
        fileName = 'prisma/schema.prisma';
        content = generatePrismaSchema(options);
        break;
      case 'sequelize':
        fileName = 'models/index.js';
        content = generateSequelizeModel(options);
        break;
      default:
        return NextResponse.json(
          { error: 'Invalid file type' },
          { status: 400 }
        );
    }

    // Save to database
    const generatedFile = await prisma.generatedFile.create({
      data: {
        fileType: type,
        fileName,
        content,
        repo,
        owner,
        committed: false
      }
    });

    // Clone repo and commit
    await fs.mkdir(tempDir, { recursive: true });
    
    const repoUrl = token
      ? `https://${token}@github.com/${owner}/${repo}.git`
      : `https://github.com/${owner}/${repo}.git`;

    const git = simpleGit();
    await git.clone(repoUrl, tempDir);
    
    // Now work in the cloned directory
    const repoGit = simpleGit(tempDir);
    
    // Create directory if needed (for prisma/)
    const filePath = path.join(tempDir, fileName);
    const fileDir = path.dirname(filePath);
    await fs.mkdir(fileDir, { recursive: true });
    
    // Write file
    await fs.writeFile(filePath, content);
    
    // Commit and push
    await repoGit.add(fileName);
    await repoGit.commit(`Add ${fileName} - Generated by Assignment 2 App`);
    await repoGit.push('origin', 'main');

    // Get the latest commit hash
    const log = await repoGit.log({ maxCount: 1 });
    const commitHash = log.latest?.hash || 'unknown';

    // Update database with commit hash
    await prisma.generatedFile.update({
      where: { id: generatedFile.id },
      data: {
        committed: true,
        commitHash: commitHash
      }
    });

    // Cleanup
    await fs.rm(tempDir, { recursive: true, force: true });

    console.log(`[API] Successfully generated and committed ${fileName}`);
    return NextResponse.json({
      success: true,
      message: `${fileName} committed successfully`,
      file: generatedFile
    });

  } catch (error: any) {
    console.error('[API] Generate/commit error:', error);
    
    // Cleanup on error
    try {
      await fs.rm(tempDir, { recursive: true, force: true });
    } catch {}

    return NextResponse.json(
      { error: error.message || 'Failed to generate and commit file' },
      { status: 500 }
    );
  }
}

// Helper functions for file generation
function generateDockerfile(options: any) {
  const nodeVersion = options?.nodeVersion || '22';
  const port = options?.port || 3000;
  
  return `FROM node:${nodeVersion}-alpine

WORKDIR /app

COPY package*.json ./
RUN npm ci --only=production

COPY . .
RUN npm run build

EXPOSE ${port}

CMD ["npm", "start"]`;
}

function generateDockerCompose(options: any) {
  const dbType = options?.dbType || 'postgres';
  const dbName = options?.dbName || 'mydb';
  const dbUser = options?.dbUser || 'user';
  const dbPassword = options?.dbPassword || 'password';
  const dbPort = options?.dbPort || 5432;
  
  return `version: '3.8'

services:
  ${dbType}:
    image: ${dbType}:16-alpine
    environment:
      POSTGRES_DB: ${dbName}
      POSTGRES_USER: ${dbUser}
      POSTGRES_PASSWORD: ${dbPassword}
    ports:
      - "${dbPort}:5432"
    volumes:
      - db_data:/var/lib/postgresql/data

  app:
    build: .
    ports:
      - "3000:3000"
    environment:
      DATABASE_URL: postgresql://${dbUser}:${dbPassword}@${dbType}:5432/${dbName}
    depends_on:
      - ${dbType}

volumes:
  db_data:`;
}

function generatePrismaSchema(options: any) {
  const tables = options?.tables || [];
  
  const models = tables.map((table: any) => {
    const fields = table.fields.map((field: any) => 
      `  ${field.name} ${field.type}`
    ).join('\n');
    
    return `model ${table.name} {
  id Int @id @default(autoincrement())
${fields}
  createdAt DateTime @default(now())
}`;
  }).join('\n\n');

  return `generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

${models}`;
}

function generateSequelizeModel(options: any) {
  const tableName = options?.tableName || 'User';
  const fields = options?.fields || [];
  
  const fieldDefs = fields.map((field: any) => 
    `    ${field.name}: {
      type: DataTypes.${field.type.toUpperCase()},
      allowNull: ${field.required ? 'false' : 'true'}
    }`
  ).join(',\n');

  return `const { DataTypes } = require('sequelize');

module.exports = (sequelize) => {
  const ${tableName} = sequelize.define('${tableName}', {
${fieldDefs}
  });

  return ${tableName};
};`;
}